# 深入理解TCP

## Socket

套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息

- 连接使用的协议
- 本地主机的IP地址
- 本地进程的协议端口
- 远地主机的IP地址
- 远地进程的协议端口

## 3次握手与4次分手

### TCP协议头部的格式

- Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；
- Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；
- Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；
- Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；

TCP首部中有6个标志比特

- SYN(synchronous建立联机)，同步序号，用来建立连接,SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1
- ACK(acknowledgement 确认)
- PSH(push传送) 在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队
- FIN(finish结束) 送端已经达到数据末尾，双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。
- RST(reset重置) 复位那些产生错误的连接，也被用来拒绝错误和非法的数据包
- URG(urgent紧急),保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据

### 三次握手

- 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入`SYN_SENT`状态，等待服务器的确认；
- 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入`SYN_RECEIVED`状态；
- 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入`ESTABLISHED`状态，完成TCP三次握手。

完成了三次握手，客户端和服务器端就可以开始传送数据。

### 四次分手

- 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入`FIN_WAIT_1`状态；这表示主机1没有数据要发送给主机2了；
- 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入`FIN_WAIT_2`状态（半关闭的状态)；主机2告诉主机1，我“同意”你的关闭请求, 此时主机2处于`CLOSE_WAIT`（被动关闭）状态；
- 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入`LAST_ACK`状态；
- 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入`TIME_WAIT`状态；主机2收到主机1的ACK报文段以后，就关闭连接；主机2则处于`CLOSED`状态，此时，主机1等待2MSL（Maximum Segment Lifetime,报文最大生存时间）后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

## TCP连接状态

- LISTEN： 侦听来自远方的TCP端口的连接请求
- SYN_SENT： 发送连接请求后等待匹配的连接请求
- SYN_RECEIVED：收到和发送一个连接请求后等待对方对连接请求的确认
- ESTABLISHED： 代表一个打开的连接
- FIN_WAIT_1： 等待远程TCP连接中断请求，或先前的连接中断请求的确认
- FIN_WAIT_2： 从远程TCP等待连接中断请求
- CLOSE_WAIT： 等待从本地用户发来的连接中断请求
- CLOSING： 等待远程TCP对连接中断的确认（少见）
- LAST_ACK： 等待原来的发向远程TCP的连接中断请求的确认
- TIME_WAIT： 等待足够的时间以确保远程TCP接收到连接中断请求的确认（2MSL等待状态)
- CLOSED： 没有任何连接状态

## TCP状态迁移

客户端状态迁移

`CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED`

服务器状态迁移

`CLOSED->LISTEN->SYN_RECEIVED->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED`

其他状态迁移

`LISTEN->SYN_SENT`，服务器有时候也要打开连接主动发送消息

`SYN_SENT->SYN_RECEIVED` 服务器和客户端在SYN_SENT状态下如果收到SYN数据报，则都需要发送SYN的ACK数据报并把自己的状态调整到SYN_RECEIVED状态，准备进入ESTABLISHED

`SYN_SENT->CLOSED`，在发送超时的情况下，会返回到CLOSED状态。

`SYN_RECEIVED->LISTEN`，如果受到RST包，会返回到LISTEN状态。

`SYN_RECEIVED->FIN_WAIT_1`，可以不用到ESTABLISHED状态，而可以直接跳转到FIN_WAIT_1状态并等待关闭。

## 心跳程序设计

### 半连接问题

当服务器断电、断网、丢弃三次握手的ack包都可能造成客户端半连接，同时客户端断电、断网，或者中间设备故障也可能造成服务器端半连接。

半连接出现后，从系统层面考虑，对服务器而言，害怕的是量大导致资源耗尽从而拒绝服务；对客户端而言，系统危害不大，连接一致性无法保证。从业务层面而言，如果是长连接的推送服务，如果客户端故障导致，将导致推送数据失败。心跳包让哪一方来发依赖于是否需要感知对方断开了通信连接

1. 客户端向服务端发送心跳

    - 客户端设计 定时发送心跳到服务端，并启动一个超时定时器，如果服务器有响应心跳，删除定时器，如果没有响应，说明网络断了或者被服务器主动断掉链接，需要在定时器程序中重连
    - 服务端设计 响应客户端心跳，定时清理长时间不活跃的客户端

1. 服务端向客户端发送心跳，对服务器资源消耗大，好处在于便于集中管理，服务端可以随时发心跳掌握客户端状态，不必等待。
1. 两边互相发送心跳，适用于推送服务

    - 客户端设计 定时发送心跳到服务端，并启动一个超时定时器，如果服务器有响应心跳，删除定时器，如果没有响应，说明网络断了或者被服务器主动断掉链接，需要在定时器程序中重连
    - 服务端设计 定时发送心跳到客户端，如果客户端没有响应快速回收资源

## 疑问

### 为什么是三次握手，不是两次握手

### 为什么握手三次，分手四次

### 第四次分手中，发送ACK消息后为什么要等待2MSL时间才能返回到CLOSED状态