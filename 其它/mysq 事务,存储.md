## 事务

事务的ACID属性 原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)

Atomicity

innodb通过undo log(回滚日志)和redo log（重做日志）来实现 原子性及持久性, 所有事务进行的修改都会先记录到回滚日志中，然后在对数据库中的对应行进行写入, 回滚日志除了能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚, 回滚日志是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库中的修改撤销掉看，可以理解为，我们在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句

隔离性包括

- 读未提交：(Read Uncommitted) 会引起脏读， 例如一个进程更改了其中的一行数据，修改完之后就释放了锁，另一个进程读取了该数据，此时先前的事务是还未提交的，这时第一个进程回滚了数据，另一个进程读的数据就变成了无用的或者是错误的数据。这种情况叫脏读，
- 读已提交 或者 不可重复读（Read Committed） oracle,sqlserver,pg大多数数据库默认的隔离级别，在事务提交前，其他进程是无法对该行数据进行读取的. 多次使用查询语句时，可能得到不同的结果。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读. 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。
- 可重复读（Repeatable-Read) mysql数据库所默认的级别，例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读  幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。mysql 通过MVCC并发版本控制来解决不可重读和幻读，具体是：如果事务中存在多次读取同样的数据，MySQL第一次读的时候仍然会保持选择读最新提交事务的数据，当第一次之后，之后再读时，mysql会取第一次读取的数据作为结果。这样就保证了同一个事务多次读取数据时数据的一致性。
- 序列化（serializable）

为什么mysql 默认的事务隔离级别为可重复读？

因为mysql 最开始的主从复制(5.1版本之前)的binlog 是基于 statement 格式的，这种格式在读已提交 的事务隔离级别下的主从复制是有bug，所以mysql 将 默认的事务隔离级别设置为可重复读

### MVCC 多版本并发控制

- 大多数的MySQL事务型存储引擎，如InnoDB都不止使用简单的行加锁机制，都和MVCC-多版本并发控制一起使用
- 锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销

MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制


### 锁

- 悲观锁
- 乐观锁
- 共享锁(读锁)
- 排它锁(写锁、独占锁)
- 行锁
- 表锁

## 数据存储